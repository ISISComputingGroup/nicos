#!/usr/bin/env python
#  -*- coding: utf-8 -*-
# *****************************************************************************
# NICOS, the Networked Instrument Control System of the MLZ
# Copyright (c) 2009-2017 by the NICOS contributors (see AUTHORS)
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# Module authors:
#   Georg Brandl <georg.brandl@fz-juelich.de>
#
# *****************************************************************************

import argparse
import atexit
import os
import signal
import subprocess
import sys

from os import path
from time import sleep

import psutil

thisfile = path.realpath(__file__)
bin_path = path.normpath(path.dirname(thisfile))

if not os.environ.get('INSTRUMENT'):
    os.environ['INSTRUMENT'] = 'nicos_demo.demo'

dev_null = open(os.devnull, 'wb')
background_processes = []


def echo(s):
    sys.stdout.write(s)
    sys.stdout.flush()


def spawn(script, *args, **kwds):
    wait = kwds.pop('wait', False)
    stdout = dev_null if not wait else None
    executable = (sys.executable,)
    prof = kwds.get('profile', None)
    if prof == 'mprof':
        executable = ('mprof', 'run', '--include-children', '--python')
    if prof == 'kernprof':
        executable = ('kernprof',)
    if prof == 'line_prof':
        executable = ('kernprof', '--line-by-line')
    p = subprocess.Popen(executable + (path.join(bin_path, script),) + args,
                         stdout=stdout)
    if wait:
        try:
            p.wait()
        except KeyboardInterrupt:
            p.terminate()
    else:
        nice_name = '%s %s' % (script, ' '.join(args))
        background_processes.append((nice_name, p, prof))


def wait():
    echo('Services started, press Enter to stop them.\n')
    try:
        raw_input()
    except (KeyboardInterrupt, EOFError):
        pass


@atexit.register
def cleanup():
    # clean up processes, even if nicos-demo is terminated early
    if background_processes:
        echo('Cleaning up...\n')
    pgid = None
    for nice_name, proc, prof in reversed(background_processes):
        try:
            if not pgid and hasattr(os, 'getpgid'):
                pgid = os.getpgid(proc.pid)
            if prof == 'mprof' or os.name == 'nt':
                parent = psutil.Process(proc.pid)
                children = parent.children()
                proc.terminate()
                for c in children:
                    c.terminate()
                sleep(0.5)
            else:
                proc.terminate()
        except OSError as e:
            # might already have terminated early
            echo('could not stop %s %s: %s\n' % (nice_name, e))
        else:
            proc.wait()
    # under some circumstances (re-start due to internal errors)
    # the poller or watchdog may become detached
    # from its parents, so do a final safety kill
    if pgid:
        os.killpg(pgid, signal.SIGTERM)
    echo('NICOS demo finished.\n')


parser = argparse.ArgumentParser()
parser.add_argument('-E', dest='noelog', action='store_true',
                    help='disable electronic logbook')
parser.add_argument('-W', dest='nowatchdog', action='store_true',
                    help='disable watchdog')
parser.add_argument('-M', dest='nomonitor', action='store_true',
                    help='disable monitor')
parser.add_argument('-m', dest='monitorsetup', action='store',
                    help='use given monitor setup instead of the default one')
parser.add_argument('-H', dest='htmlmonitor', action='store_true',
                    help='start the web status service')
parser.add_argument('-O', dest='oh', action='store',
                    help='does nothing (yet)')

parser.add_argument('-D', dest='nodaemon', action='store_true',
                    help='disable daemon')
parser.add_argument('--clear-cache', dest='clearcache', action='store_true',
                    help='clear the cache')
parser.add_argument('-T', dest='textclient', action='store_true',
                    help='start text daemon client instead of GUI')
parser.add_argument('-N', dest='noclient', action='store_true',
                    help='do not start any client')
parser.add_argument('-t', dest='aioclient', action='store_true',
                    help='disable daemon and start console shell')

parser.add_argument('-c', dest='guiconfig', action='store',
                    help='use given GUI config file instead of the default one')
parser.add_argument('-u', dest='guiuser', action='store',
                    default='guest:guest@localhost',
                    help='use given user:password@server for the daemon login')
# It usually doesn't make sense to start this service.  Therefore it is set
# to False by default and only has a long option.
parser.add_argument('--pushversioninfo', dest='pushversioninfo',
                    action='store_true', default=False,
                    help='Start the version update daemon')

parser.add_argument('--profile', dest='profile',
                    action='store', default=None,
                    choices=['mprof', 'kernprof', 'line_prof'],
                    help='''Start processes with profiling - available:
'mprof': Run the mprof memory profiler,
'kernprof': Run kernprof globally,
'line_prof': Run kernprof in line_by_line mode.
See https://pypi.python.org/pypi/memory_profiler and
https://github.com/rkern/line_profiler for extended documentation.''')

parser.add_argument('restargs', nargs=argparse.REMAINDER,
                    help=argparse.SUPPRESS)

opts = parser.parse_args()

if opts.profile:
    spawnargs = {'profile': opts.profile}
else:
    spawnargs = {}

echo('Starting NICOS demo system, please wait:')

if not opts.clearcache:
    spawn('nicos-cache', **spawnargs)
else:
    spawn('nicos-cache', '--clear', **spawnargs)
echo(' cache')
sleep(2)

if opts.pushversioninfo:
    spawn('nicos-pushversioninfo', **spawnargs)
    echo(' pushversioninfo')
    sleep(0.1)

if not opts.nowatchdog:
    spawn('nicos-watchdog', **spawnargs)
    echo(' watchdog')
    sleep(0.1)

if not opts.noelog:
    spawn('nicos-elog', **spawnargs)
    echo(' elog')
    sleep(0.1)

spawn('nicos-poller', **spawnargs)
echo(' poller')
sleep(0.1)

if not opts.nomonitor:
    monitorargs = ['-S', 'monitor-' + opts.monitorsetup] \
        if opts.monitorsetup else []
    if opts.nodaemon:
        echo('.\n')
        spawn('nicos-monitor', *monitorargs, wait=True, **spawnargs)
    else:
        spawn('nicos-monitor', *monitorargs, **spawnargs)
        echo(' monitor')
        sleep(0.1)

if opts.htmlmonitor:
    monitorargs = ['-S', 'monitor-html']
    spawn('nicos-monitor', *monitorargs, **spawnargs)
    echo(' web-monitor')

if opts.aioclient:
    echo('\nServices started, starting console.\n')
    spawn('nicos-aio', wait=True, **spawnargs)
elif not opts.nodaemon:
    spawn('nicos-daemon', **spawnargs)
    echo(' daemon')
    sleep(1)
    echo('.\n')
    if not opts.noclient:
        if opts.textclient:
            spawn('nicos-client', opts.guiuser, wait=True, **spawnargs)
        else:
            echo('Services started, starting GUI.\n')
            guiargs = ['-c', opts.guiconfig] if opts.guiconfig else []
            guiargs.extend([opts.guiuser] + opts.restargs)
            spawn('nicos-gui', *guiargs, wait=True, **spawnargs)
    else:
        wait()
else:
    echo('.\n')
    wait()
