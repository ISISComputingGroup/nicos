#!/usr/bin/env python

import os
import sys
import Queue
import signal
import select
import socket
import threading
import ConfigParser
from time import sleep, time as currenttime

try:
    from setproctitle import setproctitle
except ImportError:
    setproctitle = lambda title: None

import TACOClient
from PowerSupply import CurrentControl, VoltageControl
from Temperature import Controller, Sensor
from Motor import Motor
from Encoder import Encoder
from IO import AnalogInput, AnalogOutput, DigitalInput, DigitalOutput, \
     Timer, Counter


# -- cache client --------------------------------------------------------------

DEFAULT_CACHE_PORT = 14869

def cache_dump(obj):
    res = []
    if isinstance(obj, (int, long, bool, float, str, unicode)):
        res.append(repr(obj))
    elif isinstance(obj, list):
        res.append('[')
        for item in obj:
            res.append(cache_dump(item))
            res.append(',')
        res.append(']')
    elif isinstance(obj, tuple):
        res.append('(')
        for item in obj:
            res.append(cache_dump(item))
            res.append(',')
        res.append(')')
    elif isinstance(obj, dict):
        res.append('{')
        for key, value in obj.iteritems():
            res.append(cache_dump(key))
            res.append(':')
            res.append(cache_dump(value))
            res.append(',')
        res.append('}')
    else:
        raise ValueError('unserializable object: %r' % obj)
    return ''.join(res)

class CacheClient(object):
    """
    A minimal write client for the NICM cache.
    """

    def __init__(self, server, prefix, log, ttl):
        self._log = log
        self._ttl = ttl
        try:
            host, port = server.split(':')
            port = int(port)
        except ValueError:
            host, port = server, DEFAULT_CACHE_PORT
        self._address = (host, port)
        self._socket = None
        self._prefix = prefix.strip('/')
        self._selecttimeout = 1.0  # seconds

        self._stoprequest = False
        self._queue = Queue.Queue()

        # create worker thread, but do not start yet, leave that to subclasses
        self._worker = threading.Thread(target=self._worker_thread)
        self._worker.setDaemon(True)
        self._worker.start()

    def _connect(self):
        self._socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            self._socket.connect(self._address)
        except Exception, err:
            self._disconnect('unable to connect to %s:%s: %s' %
                             (self._address + (err,)))
        else:
            self._log('now connected to %s:%s' % self._address)

    def _disconnect(self, why=''):
        if not self._socket:
            return
        if why:
            self._log(why)
        try:
            self._socket.shutdown(socket.SHUT_RDWR)
            self._socket.close()
        except Exception:
            pass
        self._socket = None

    def _worker_thread(self):
        while not self._stoprequest:
            if not self._socket:
                self._connect()
                if not self._socket:
                    sleep(5)
                    continue
            # determine if something needs to be sent
            try:
                tosend = self._queue.get(False)
                writelist = [self._socket]
            except:
                tosend = None
                writelist = []
            # try to read or write some data
            res = select.select([], writelist, [self._socket],
                                self._selecttimeout)
            if res[2]:
                # handle error case: close socket and reopen
                self._disconnect('disconnect: socket in error state')
            elif res[1]:
                # write data
                try:
                    while tosend:
                        sent = self._socket.send(tosend)
                        tosend = tosend[sent:]
                except:
                    self._disconnect('disconnect: send failed')
        # end of while loop
        self._disconnect()

    def put(self, key, value):
        time = currenttime()
        msg = '%s+%s@%s/%s=%s\r\n' % (time, self._ttl, self._prefix, key,
                                      cache_dump(value))
        self._queue.put(msg)


# -- poller objects ------------------------------------------------------------

registry = {}

aliasmap = {
    ('IOAnalogOutput', 'MotorMotor'): 1,
    ('EncoderEncoder', 'IOAnalogInput'): 0,
    ('IOAnalogOutput', 'TemperatureController'): 1,
    ('IOAnalogInput', 'TemperatureSensor'): 1,
}

typemap = {
    'EncoderEncoder': Encoder,
    'IOAnalogInput': AnalogInput,
    'IOAnalogOutput': AnalogOutput,
    'IOCounter': Counter,
    'IOTimer': Timer,
    'IODigitalInput': DigitalInput,
    'IODigitalOutput': DigitalOutput,
    'PowerSupplyCurrentControl': CurrentControl,
    'PowerSupplyVoltageControl': VoltageControl,
    'MotorMotor': Motor,
    'TemperatureController': Controller,
    'TemperatureSensor': Sensor,
}

class PollerMeta(type):
    def __init__(cls, name, bases, dict):
        if cls.tacotype:
            registry[cls.tacotype] = cls

class Poller(object):
    __metaclass__ = PollerMeta
    tacotype = None

    def __init__(self, tacodev, connection):
        self.client = self.tacotype(tacodev)
        self.connection = connection

    def poll(self, cycle):
        self.connection.put('value', self.client.read())
        self.extra_poll(cycle)

    def extra_poll(self, cylce):
        pass

class TempCtrlPoller(Poller):
    tacotype = Controller

    def extra_poll(self, cycle):
        if cycle % 20 == 0:
            self.connection.put('p', self.client.pParam())
            self.connection.put('i', self.client.iParam())
            self.connection.put('d', self.client.dParam())

class TempSensPoller(Poller):
    tacotype = Sensor

class TimerPoller(Poller):
    tacotype = Timer

class CounterPoller(Poller):
    tacotype = Counter

class DigInputPoller(Poller):
    tacotype = DigitalInput

class DigOutputPoller(Poller):
    tacotype = DigitalOutput

class AnalogInputPoller(Poller):
    tacotype = AnalogInput

class AnalogOutputPoller(Poller):
    tacotype = AnalogOutput

class CurrentControlPoller(Poller):
    tacotype = CurrentControl

def poll(devname, taconame):
    prefix = cacheprefix.strip('/') + '/' + devname
    if ',' in taconame:
        taconame, delay = taconame.split(',')
        taconame = taconame.strip()
        delay = int(delay.strip())
    else:
        delay = 1
    ttl = delay * 2
    connection = CacheClient(cacheserver, prefix, log, ttl)
    client = TACOClient.Client(taconame)
    types = client.deviceTypes()
    if tuple(types) in aliasmap:
        type = types[aliasmap[tuple(types)]]
    else:
        type = types and types[-1] or ''
    if type not in typemap:
        log('%s is a %s, which cannot be polled' % (taconame, types))
        return
    cls = registry[typemap[type]]
    poller = cls(taconame, connection)
    i = 0
    while True:
        i += 1
        try:
            poller.poll(i)
        except TACOClient.TACOError, err:
            log('Could not poll %s: %s' % (taconame, err))
        sleep(delay)

def log(x):
    print x

if len(sys.argv) != 2:
    print >>sys.stderr, 'Usage: taco-poller configfile'
    sys.exit(1)

cfg = ConfigParser.RawConfigParser()
cfg.read(sys.argv[1])

cacheprefix = cfg.get('cache', 'prefix')
cacheserver = cfg.get('cache', 'server')

tacohost = cfg.get('poller', 'host')
tacoprefix = cfg.get('poller', 'prefix')
devices = cfg.options('devices')

# fork one process per device
children = []
for device in devices:
    short_taconame = cfg.get('devices', device)
    taconame = '//%s/%s%s' % (tacohost, tacoprefix, short_taconame)
    child_pid = os.fork()
    if child_pid == 0:
        # child
        setproctitle('taco-poller for %s' % device)
        poll(device, taconame)
        sys.exit()
    else:
        log('Started worker process %d for %s' % (child_pid, device))
        children.append(child_pid)

def kill_all(*ignored):
    log('killing all children')
    for child in children:
        os.kill(child, signal.SIGTERM)
    sys.exit()
signal.signal(signal.SIGINT, kill_all)
signal.signal(signal.SIGTERM, kill_all)

# wait for anything interesting to happen
while True:
    sleep(1)
