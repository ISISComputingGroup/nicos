#!/usr/bin/env python

import os
import sys
import time
import signal
import ConfigParser
from os import path

import sys, os
from os import path
thisfile = path.abspath(__file__)
while path.islink(thisfile):
    thisfile = path.join(path.dirname(thisfile), os.readlink(thisfile))
root_path = path.normpath(path.join(path.dirname(thisfile), '..'))

# XXX put DAEMONS into nicos.conf
DAEMONS = ['cache', 'poller', 'daemon']

try:
    action = sys.argv[1]
except IndexError:
    print >>sys.stderr, 'Usage: %s start|stop|restart|status' % sys.argv[0]
    sys.exit(1)

class NicosConfigParser(ConfigParser.SafeConfigParser):
    def optionxform(self, key):
        return key

def read_config():
    cfg = NicosConfigParser()
    cfg.read(path.join(root_path, 'nicos.conf'))
    if cfg.has_section('environment'):
        for name in cfg.options('environment'):
            value = cfg.get('environment', name)
            os.environ[name] = value

read_config()

def read_pidfile(name, wait=0):
    begin = time.time()
    pidpath = path.join(root_path, 'pid', '%s.pid' % name)
    while True:
        try:
            pid = file(pidpath, 'rb').read()
        except:
            if time.time() > begin + wait:
                return
        else:
            break
        time.sleep(0.1)
    # check that pid really exists
    pid = int(pid)
    try:
        params = open('/proc/%d/cmdline' % pid, 'r').read().split('\0')
        if not params[1].endswith(name):   # not our process?
            raise ValueError
        return pid
    except Exception:
        try:
            os.unlink(pidpath)
        except Exception:
            pass
        return

def start_daemon(name):
    print 'Starting %s...' % name,
    sys.stdout.flush()
    previous_pid = read_pidfile(name)
    if previous_pid:
        print 'already running? (pid = %d)' % previous_pid
        return
    os.system('%s -d' % path.join(root_path, 'bin', 'nicos-%s' % name))
    pid = read_pidfile(name, wait=20)
    if not pid:
        print 'failed'
        sys.exit(1)
    print 'pid =', pid

def kill_daemon(name):
    print 'Killing %s...' % name,
    sys.stdout.flush()
    pid = read_pidfile(name)
    if not pid:
        print 'not running?'
    else:
        print 'pid =', pid
        os.kill(pid, signal.SIGTERM)

if action == 'start':
    for name in DAEMONS:
        start_daemon(name)

elif action == 'stop':
    for name in reversed(DAEMONS):
        kill_daemon(name)

elif action == 'restart':
    os.system('%s stop && sleep 1 && %s start' % (sys.argv[0], sys.argv[0]))

elif action == 'status':
    for name in DAEMONS:
        pid = read_pidfile(name)
        if pid:
            print '%-10s: running (pid = %s)' % (name, pid)
        else:
            print '%-10s: dead' % name

else:
    print >>sys.stderr, 'Usage: %s start|stop|restart|status' % sys.argv[0]
    sys.exit(1)
