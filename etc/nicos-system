#!/usr/bin/env python
### BEGIN INIT INFO
# Provides: nicos-system
# Required-Start: $local_fs $remote_fs $network $named
# Required-Stop: $local_fs $remote_fs $network
# Default-Start: 2 3 4 5
# Default-Stop: 0 1 6
# Description: Network Integrated Control System init script
### END INIT INFO
# *****************************************************************************
# NICOS, the Networked Instrument Control System of the FRM-II
# Copyright (c) 2009-2014 by the NICOS contributors (see AUTHORS)
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# Module authors:
#   Georg Brandl <georg.brandl@frm2.tum.de>
#
# *****************************************************************************

import os
import sys
import time
import socket
import signal
import ConfigParser
from os import path

control_path = path.dirname(path.dirname(path.realpath(__file__)))

try:
    import nicos
except ImportError:
    sys.path.insert(0, control_path)

# We need to read the nicos.conf file, so let nicos/__init__.py do that.
from nicos.core.sessions import Session


def get_config():
    hostname = ''
    try:
        hostname = socket.getfqdn().split('.')[0]
    except socket.error as e:
        print >>sys.stderr, \
            'Could not figure out host name (%s).' % str(e)
        print >>sys.stderr, \
            'Continue with nonspecific services.'
    host_spec_services = 'services_%s' % hostname

    if hostname and hasattr(Session.config, host_spec_services):
        services = getattr(Session.config, host_spec_services)
    else:
        services = Session.config.services
    log_path = path.join(control_path, Session.config.logging_path)
    pid_path = path.join(control_path, Session.config.pid_path)
    if services.lower().strip() in ['', 'none']:
        services = []
    else:
        services = [svc.strip() for svc in services.split(',')]
    return services, log_path, pid_path

SERVICES, LOG_PATH, PID_PATH = get_config()

def usage():
    print >>sys.stderr, \
          'Usage: %s start|stop|restart|status [service ...]' % sys.argv[0]
    print >>sys.stderr, \
          'Possible services are %s' % ', '.join(SERVICES)
    sys.exit(1)

try:
    action = sys.argv[1]
except IndexError:
    usage()

all_option = False
explicit_daemons = False

daemon_args = sys.argv[2:]
if '-a' in daemon_args:
    all_option = True
    daemon_args.remove('-a')
if daemon_args:
    explicit_daemons = True
    daemons = daemon_args
    for daemon in daemons:
        if daemon not in SERVICES:
            usage()
else:
    daemons = SERVICES

def read_pidfile(name, wait=0):
    begin = time.time()
    pidpath = path.join(PID_PATH, '%s.pid' % name)
    while True:
        try:
            pid = file(pidpath, 'rb').read()
            pid = int(pid)
        except:
            if time.time() > begin + wait:
                return
        else:
            break
        time.sleep(0.1)
    # check that pid really exists
    try:
        params = open('/proc/%d/cmdline' % pid, 'r').read().split('\0')
        if '-' in name:
            procname, instname = name.split('-')
            if not params[1].endswith(procname) and instname in params[2:]:
                raise ValueError
        elif not params[1].endswith(name):   # not our process?
            raise ValueError
        return pid
    except Exception:
        try:
            os.unlink(pidpath)
        except Exception:
            pass
        return

def start_daemon(name):
    print 'Starting %s...' % name,
    sys.stdout.flush()
    previous_pid = read_pidfile(name)
    if previous_pid:
        print 'already running? (pid = %d)' % previous_pid
        return
    try:
        procname, instname = name.split('-')
    except:
        procname, instname = name, None
    executable = path.join(control_path, 'bin', 'nicos-%s' % procname)
    os.system('%s%s -d' % (executable, ' -S %s' % (name,) if instname
                           else '', ))
    pid = read_pidfile(name, wait=10)
    if not pid:
        print 'failed, please look in the logfile at %s' % \
            path.join(LOG_PATH, name, name + time.strftime('-%Y-%m-%d.log'))
        sys.exit(1)
    print 'pid =', pid
    if name == 'cache':
        time.sleep(3)

def kill_daemon(name):
    print 'Killing %s...' % name,
    sys.stdout.flush()
    pid = read_pidfile(name)
    if not pid:
        print 'not running?'
    else:
        print 'pid =', pid
        os.kill(pid, signal.SIGTERM)

if action == 'start':
    for name in daemons:
        start_daemon(name)

elif action == 'stop':
    if not all_option and not explicit_daemons and 'cache' in daemons:
        print 'Not stopping cache, use -a option to force'
        daemons.remove('cache')
    for name in reversed(daemons):
        kill_daemon(name)

elif action == 'restart':
    if not all_option and not explicit_daemons and 'cache' in daemons:
        print 'Not restarting cache, use -a option to force'
        daemons.remove('cache')
    dmns = ' '.join(daemons)
    os.system('%s stop %s && sleep 1 && %s start %s' % (
        sys.argv[0], dmns, sys.argv[0], dmns))

elif action == 'status':
    exitstatus = 0
    for name in daemons:
        pid = read_pidfile(name)
        if pid:
            print '%-12s: running (pid = %s)' % (name, pid)
        else:
            print '%-12s: dead' % name
            exitstatus = 1
    sys.exit(exitstatus)

else:
    print >>sys.stderr, 'Usage: %s start|stop|restart|status' % sys.argv[0]
    sys.exit(2)
