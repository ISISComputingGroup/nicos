.. -*- mode: rst -*-

===============
Writing devices
===============

:Author:   $Author$
:Date:     $Date$
:Revision: $Revision$

`Back to index <index.html>`_

.. contents::

----------------
Device interface
----------------

NICOS models every device type as a Python class, and concrete devices as
instances of these classes.  There are also abstract classes that do not map to
real devices, but serve to define the interface for derived classes.

For almost any action on a device, there are two methods:

* The public method, e.g. ``device.start()`` is what the user or a user command
  will call.  It typically is only present on the most abstract class that has
  that method and delegates most of the work to the implementation method,
  except for repetitive tasks that always have to be executed for that action.
* The implementation method, prefixed with ``do``, e.g. ``device.doStart()``
  executes the action for the specific device.  It is overwritten in specific
  subclasses.

When writing a device class for a specific device, only those implementation
methods need to written that the device can support; the others will be skipped
when called by the public methods.

--------------
Device classes
--------------

The base classes for all devices are contained in the module ``nicos.device``.
There is a hierarchy of classes that correspond to varying levels of interaction
that is possible with the device:

``Device``
==========

This class supports setting parameters from the configuration, and allows the
user to get and set parameter values.

Device objects must have a ``parameters`` class attribute that defines the
available additional parameters.  It must be a dictionary mapping parameter name
to a tuple of ``(default, mandatory, description)`` where *default* is the
default value, *mandatory* specifies whether the parameter must be set in the
configuration, and *description* describes the parameter shortly.

The ``parameters`` attribute does *not* need to contain the parameters of base
classes again, they are automatically merged.  (But it *can* contain a parameter
defined by a base class, in order to override its properties.  For example,
while usually the ``unit`` parameter is mandatory, it can be omitted for devices
that can find out their unit automatically.)

Device classes can also have an ``attached_devices`` attribute that defines the
class's "attached devices" it needs to operate, such as a low-level
communication device, or motor and encoders for an axis class.  It maps the
"internal name" (the device will be available as an attribute with that name) to
the type of the device (which usually is an abstract type).  For example::

   attached_devices = {'motor': nicos.motor.Motor, 'coder': nicos.coder.Coder}

The actual attached devices for a specific instance (given in the instance's
configuration) are then type-checked against these types.  As a special case, if
the type is a list containing one type, such as ``[Readable]``, the
corresponding entry in the configuration must be a list of zero to many
instances of that type.

The ``attached_devices`` attribute does *not* need to contain the entries of
base classes again, they are automatically merged.

Public methods
--------------

``init()``
   *Interface:* Initialize the device.  This method is called by the NICOS system
   when the device instance has been created, all parameters are set and all
   attached devices have been created and initialized.

   *Implementation:* Simply calls a ``doInit()`` method if present.

``shutdown()``
   *Interface:* Shut down the device.  This method is called by the NICOS system
   when the device is destroyed, manually or because the current setup is
   unloaded.

   *Implementation:* Simply calls a ``doShutdown()`` method if present.

``getPar(name)``
   *Interface:* Return the parameter given by *name*.

   *Implementation:* A getter method is automatically created for each
   parameter, e.g. ``getUnit()`` for the *unit* parameter.  Each of these
   getters calls a ``doGetParamname()`` (e.g. ``doGetUnit()``) method if
   present, otherwise simply returns the parameter value from an internal
   dictionary, ``_params``.

   Within a device class, methods *can* directly use parameter values from
   ``self._params``, but are advised to use the ``getParamname()`` function when
   possible.

``setPar(name, value)``
   *Interface:* Set the parameter given by *name* to *value*.  If the given
   value is invalid for this parameter, raise ``ConfigurationError``.

   *Implementation:* A setter method is automatically created for each
   parameter, e.g. ``setUnit(value)`` for the *unit* parameter.  Each of these
   setters calls a ``doSetParamname(value)`` method if present, otherwise
   assumes that the parameter is not settable and raises ``ConfigurationError``.
   The ``doSetParamname`` method should raise ``ConfigurationError`` for invalid
   values and otherwise set the new value in the ``_params`` dictionary in
   addition to device-specific actions (e.g. setting the new value in the
   hardware as well).

   Within a device class, methods *can* directly set parameter values in
   ``self._params``, but are advised to use the ``setParamname()`` function when
   possible.

``version()``
   *Interface:* Return a list of tuples ``(component, version)`` that describes
   the versions of components involved in the device.  "Components" are not
   further defined and can be modules, TACO servers etc.

   *Implementation:* Retrieves versions of all Python modules that contribute to
   the class inheritance chain of the device, then extends that list with the
   result of ``doVersion()``, if present.

Parameters
----------

``name`` : string, optional
   The device name.  This parameter should not be set in the configuration, it
   is set to the chosen device name automatically.

``description`` : string, optional
   A more verbose device description.  If not given, this parameter is set to be
   the same as the ``name`` parameter.

``autocreate`` : bool, optional
   Indicates whether the device should be created automatically and be available
   to the user.  Default is true.

``loglevel`` : string, optional
   The loglevel for output from the device.  This must be set to one of the
   loglevel constants.  Default is ``info``.


``Readable``
============

This class inherits from ``Device`` and additionally supports this public
interface:

Public methods
--------------

``read()``
   *Interface:* Read and return the main value of the device.

   *Implementation:* Calls the ``doRead()`` method.  This method must be
   implemented somewhere in the inheritance chain of the concrete device class.
   The read value is then repoerted to all configured histories.

``status()``
   *Interface:* Return the status of the device, as an integer constant as
   defined by the ``nicos.status`` module.

   *Implementation:* This calls a ``doStatus()`` method, if present, and checks
   that its return value is a valid status constant.  Otherwise it returns
   ``status.UNKNOWN``.  The determined status value is then reported to all
   configured histories.

``reset()``
   *Interface:* Reset the device.

   *Implementation:* Simply calls ``doReset()`` if present, and then returns the
   new device status.

``format(value)``
   *Interface:* Format a value returned by ``read()`` into a human-readable
   string.  This e.g. transforms a returned float into a string with a fixed
   number of decimals.  It does not include the unit.

   *Implementation:* This calls a ``doFormat(value)`` method, if present, and
   otherwise formats *value* with the ``fmtstr`` parameter using Python string
   formatting (the ``%`` operator).

``history(name='value', fromtime=None, totime=None)``
   Retrieves the history of a device attribute (*name*) from one of the
   histories attached to the device.  *fromtime* and *totime* are UNIX
   timestamps that specify a limiting time window.  If no history can supply the
   requested values, ``None`` is returned.

Parameters
----------

``fmtstr`` : string, optional
   A string format template that determines how the default ``format()``
   implementation formats the device value.

``unit`` : string, mandatory
   The unit of the device value.

``histories`` : list of strings, optional
   A list of device names of "history" pseudo-devices.  These objects are
   configured in the setup like devices, and serve to save and retrieve the
   history of device values and other information like device status.


``Startable``
=============

This class inherits from ``Readable`` and is simply a common base class for
several classes that support starting, waiting and stopping.

``start(pos)``, ``moveTo(pos)``, ``move(pos)``
   *Interface:* Start movement of the device to a new position.  This method
   does not generally wait for completion of the movement.

   *Implementation:* This first checks for fixed devices and then for a valid
   position with ``isAllowed(pos)``, then calls the ``doStart(pos)`` method,
   which must exist.

``stop()``
   *Interface:* Stop any movement of the device.

   *Implementation:* This first checks for fixed devices and then simply calls
   ``doStop()`` if present.  If it is not present, it is assumed that the
   movement always completes before ``doStart()`` returns.

``wait()``
   *Interface:* Wait for movement of the device to finish.

   *Implementation:* Simply calls ``doWait()`` if present, then reads the device
   value.  If ``doWait()`` is not present, it is assumed that the movement
   always completes before ``doStart()`` returns.

``isAllowed(pos)``
   *Interface:* Check if the given position is allowed, considering the current
   limits and other status of the device.  Return a tuple ``(valid, why)`` where
   *valid* is a boolean, and *why* is a string describing the reason when
   *valid* is false.  (The ``start()`` method takes the return value of this
   method and turns it into an exception if needed.)

   *Implementation:* This calls an ``doIsAllowed(pos)`` method if present.  If
   not, ``(True, '')`` is returned.

``fix()``
   *Interface:* Forbid device movement by e.g. ``start()``.

   *Implementation:* This sets an internal "fixed" flag and additionally calls
   ``doFix()``, if present.

``release()``
   *Interface:* Allow device movement again (cancels the effect of ``fix()``).

   *Implementation:* This clears the internal "fixed" flag and additionally
   calls ``doRelease()``, if present.


``Moveable``
============

This class inherits from ``Startable`` and is the base for all devices that can
be moved continuously, like axes or power supplies.

Public methods
--------------

``moveTo(pos)``, ``move(pos)``
   Aliases for ``start(pos)``.

Parameters
----------

``absmin`` : number, optional
   Absolute minimum value for the device to move to.  This parameter cannot be
   set after creation of the device.

``absmax`` : number, optional
   Absolute maximum value for the device to move to.  This parameter cannot be
   set after creation of the device.

``usermin`` : number, optional
   Minimum value for the device to move to.  This parameter can be set after
   creation, but not lower than the ``absmin`` parameter.

``usermax`` : number, optional
   Maximum value for the device to move to.  This parameter can be set after
   creation, but not higher than the ``absmax`` parameter.


``Switchable``
==============

This class inherits from ``Startable`` and is the base for all devices that can
be switched to discrete values, like relays or digital outputs.

Switchable devices have an attribute ``switchlist`` that can be used to map
"human-readable" switch values, such as ``'in'`` and ``'out'``, to internal
values, such as ``1`` and ``0``.

Public methods
--------------

``switchTo(pos)``, ``switch(pos)``
   Aliases for ``start(pos)``.  If the *pos* is neither a key nor a value in the
   ``switchlist``, a ``UsageError`` is raised.

``format(pos)``
   This ``Readable`` method is overwritten to automatically convert "internal"
   values to human-readable values, as given by the ``switchlist``.


``Countable``
=============

This class inherits from ``Startable`` and is the base for all counters.

Public methods
--------------

``start(preset=None)``
   *Interface:* Start the counter, with either the given preset or the
   standard preset.

   *Implementation:* Calls ``doStart(preset)``.

``stop()``
   *Interface:* Stop the counter.

   *Implementation:* Calls ``doStop()``.

``resume()``
   *Interface:* Resume the counter.

   *Implementation:* Calls ``doResume()``.

``wait()``
   *Interface:* Wait until counting is complete.

   *Implementation:* Calls ``doWait()``.

``clear()``
   *Interface:* Reset the counter value to zero (or equivalent).

   *Implementation:* Calls ``doClear()``.

``setPreset(value)``
   *Interface:* Set a new standard preset.

   *Implementation:* Calls ``doSetPreset(value)``.
