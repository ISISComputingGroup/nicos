#!/usr/bin/env python
# copy setup files, making backups if needed

import sys
import os
from os import path
import shutil
import filecmp
import difflib

verbose = False

def vprint(*msg):
    if verbose:
        print ' '.join(msg)

def moveoutofway(dstname, srcname, dirok=0):
    """Rename the given file to a safe backup name.

    For the destination name, use the "emacs" .~#~ extension.

    - parameters:

      **dstname**: the file to be renamed. If it does not exist, nothing
                   will happen.

      **dirok**: normally only plain files will be renamed away, but if
                 this option is set to 1, directories will be considered as
                 well.
    """
    if not path.exists(dstname):
        vprint('Target file does not exist')
        return True
    if not path.isfile(dstname):
        if not dirok or not path.isdir(dstname):
            return
    if filecmp.cmp(dstname, srcname, shallow=0):
        vprint('Target file is unchanged')
        return False
    print 'Changes in', dstname
    with open(dstname) as s1:
        with open(srcname) as s2:
            for line in difflib.unified_diff(s1.readlines(), s2.readlines(),
                                             fromfile=dstname, tofile=srcname):
                sys.stdout.write(line)
    i = 0
    while 1:
        i += 1
        renamename = dstname + '.~%d~' % i
        if not path.exists(renamename):
            try:
                os.rename(dstname, renamename)
                print 'Existing file %s renamed to %s' % (dstname, renamename)
                return True
            except os.error:
                print 'Could not move existing file %s out of the way' % dstname
                return False


def copytreewithbackup(src, dst, symlinks=False, ignore=None):
    """Copy of shutil.copytree() with added call to moveoutofway()."""
    try:
        names = os.listdir(src)
    except os.error:
        return
    if ignore is not None:
        ignored_names = ignore(src, names)
    else:
        ignored_names = set()
    if not path.isdir(dst):
        os.makedirs(dst)
    errors = []
    for name in names:
        if name in ignored_names:
            continue
        srcname = os.path.join(src, name)
        dstname = os.path.join(dst, name)
        vprint(srcname, '->', dstname)
        try:
            if symlinks and os.path.islink(srcname):
                linkto = os.readlink(srcname)
                os.symlink(linkto, dstname)
            elif os.path.isdir(srcname):
                copytreewithbackup(srcname, dstname, symlinks, ignore)
            else:
                if moveoutofway(dstname, srcname, dirok=0):
                    shutil.copy2(srcname, dstname)
            # XXX What about devices, sockets etc.?
        except (IOError, os.error) as why:
            errors.append((srcname, dstname, str(why)))
        # catch the Error from the recursive copytree so that we can
        # continue with other files
        except shutil.Error as err:
            errors.extend(err.args[0])
    try:
        shutil.copystat(src, dst)
    except shutil.WindowsError:
        # can't copy file access times on Windows
        pass
    except OSError as why:
        errors.extend((src, dst, str(why)))
    if errors:
        raise shutil.Error(errors)


if __name__ == '__main__':

    if '-v' in sys.argv:
        verbose = True
        sys.argv.remove('-v')

    if len(sys.argv) < 2:
        print "Usage: copysetup [-v] <srcdir> <targetdir>\n"
        sys.exit(1)

    copytreewithbackup(sys.argv[1], sys.argv[2])
