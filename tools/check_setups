#!/usr/bin/env python

import os
import new
import sys
import logging
import traceback
from os import path

try:
    import nicos
except ImportError:
    thisfile = path.abspath(__file__)
    sys.path.insert(0, path.normpath(path.dirname(thisfile) + '/../lib'))

from nicos import session
from nicos.core.sessions import Session, SETUP_GROUPS
from nicos.utils.loggers import ColoredConsoleHandler

# patch the session config (the "control_path_relative" param type requires a
# valid Session.config, but "session" is currently just a bare object)
session.config = Session.config

# generate stub TACO modules as needed to be able to import nicos.devices.taco
# modules and check parameters

class NICOSTACOStub(object):
    pass

STUBS = dict(
    TACOClient = ['class Client', 'exception TACOError'],
    TACOStates = [],
    TACOCommands = [],
    DEVERRORS = [],
    IOCommon = ['MODE_NORMAL=0', 'MODE_RATEMETER=1', 'MODE_PRESELECTION=2'],
    IO = ['class AnalogInput', 'class AnalogOutput', 'class DigitalInput',
          'class DigitalOutput', 'class StringIO', 'class Timer',
          'class Counter'],
    Encoder = ['class Encoder'],
    Motor = ['class Motor'],
    PowerSupply = ['class CurrentControl', 'class VoltageControl'],
    RS485Client = ['class RS485Client'],
    Temperature = ['class Sensor', 'class Controller'],
    TMCS = ['class Channel', 'class Admin'],
    Modbus = ['class Modbus'],
    ProfibusDP = ['class IO'],
)

def generate_stubs():
    for modname, content in STUBS.iteritems():
        try:
            __import__(modname)
        except Exception:
            pass  # generate stub below
        else:
            continue
        mod = new.module(modname, "NICOS stub module")
        for obj in content:
            if obj.startswith('class '):
                setattr(mod, obj[6:], type(obj[6:], (NICOSTACOStub,), {}))
            elif obj.startswith('exception '):
                setattr(mod, obj[10:], type(obj[10:], (Exception,), {}))
            else:
                name, value = obj.split('=')
                setattr(mod, name, eval(value))
        sys.modules[modname] = mod
        root_log.info('generated TACO stub module %r' % modname)


class Handler(ColoredConsoleHandler):
    def emit(self, record):
        # reintroduce standard logging behavior that the Nicos logger overrides
        record.message = record.getMessage()
        # remove this, the Nicos handler uses it differently
        record.filename = ''
        ColoredConsoleHandler.emit(self, record)

def nicos_import(clspath):
    modname, clsname = clspath.rsplit('.', 1)
    try:
        mod =  __import__('nicos.' + modname, None, None, [clsname])
    except ImportError:
        mod =  __import__(modname, None, None, [clsname])
    return getattr(mod, clsname)

def log_exception(log):
    formatted_lines = traceback.format_exc().splitlines()
    log.error(formatted_lines[-3])
    log.error(formatted_lines[-2])
    log.error(formatted_lines[-1])
    return False

def check_setupfile(filename):
    log = logging.getLogger(filename)
    good = True
    namespace = {'device': lambda c, **kw: (c, kw)}
    # check syntax
    try:
        execfile(filename, namespace)
    except SyntaxError, e:
        log.error('SyntaxError: %s', e.msg)
        log.error(' line %d : %s', e.lineno, e.text)
        return False
    except Exception, e:
        log.error('error while executing:')
        return log_exception(log)
    log.info('syntax ok')
    # check for valid group
    group = namespace.get('group', 'optional')
    if group not in SETUP_GROUPS:
        log.error('invalid setup group %r', group)
        good = False
    # check for a description
    description = namespace.get('description', None)
    if description in (None, '') and group in ('basic', 'optional'):
        log.error('missing user-friendly setup description')
        good = False
    # check if devices are duplicated
    if group != 'special':
        devs = namespace.get('devices', {})
        for devname in devs:
            if devname in devs_seen:
                log.warning('device name %s duplicate: also in %s',
                            devname, devs_seen[devname])
            else:
                devs_seen[devname] = filename
    # check for valid device classes (if importable) and parameters
    for devname, devconfig in namespace.get('devices', {}).iteritems():
        # try to import the device class
        try:
            cls = nicos_import(devconfig[0])
        except (ImportError, RuntimeError):  # the latter for SIP
            log.warning('device class %r for %r not importable',
                        devconfig[0], devname)
            continue
        except Exception, e:
            log.error('could not get device class %r for %r:',
                      devconfig[0], devname)
            log_exception(log)
            good = False
            continue
        # check missing and unsupported parameter config entries
        config = devconfig[1]
        if not hasattr(cls, 'attached_devices'):
            log.warning("%s: class %r has no 'attached_devices'",
                        devname, cls.__name__)
        else:
            for aname, ainfo in cls.attached_devices.iteritems():
                if aname in config:
                    if isinstance(ainfo[0], list) and not (
                            isinstance(config[aname], list) or config[aname] is None):
                        log.error('%s: attached device %r value %r is not a list '
                                  'when it should be', devname, aname, config[aname])
                        good = False
                    elif not isinstance(ainfo[0], list) and isinstance(config[aname], list):
                        log.error('%s: attached device %r value %r is a list when '
                                  'it should not be', devname, aname, config[aname])
                        good = False
                    del config[aname]
                else:
                    log.error('%s: attached device %r missing', devname, aname)
                    good = False
        if not hasattr(cls, 'parameters'):
            log.warning("%s: class %r has no 'parameters'",
                        devname, cls.__name__)
        else:
            if not config.get('lowlevel', False):
                if not config.get('description'):
                    log.warning("%s: device has no description", devname)
            for pname, pinfo in cls.parameters.iteritems():
                if pname in config:
                    try:
                        pinfo.type(config[pname])
                    except ValueError, e:
                        log.error('%s: parameter %r value %r is invalid: %s',
                                  devname, pname, config[pname], e)
                        good = False
                    del config[pname]
                elif pinfo.mandatory:
                    log.error('%s: mandatory parameter %r missing', devname, pname)
                    good = False
        if config:
            log.error('%s: configured parameters not accepted by the device '
                      'class: %s', devname, ', '.join(config))
            good = False
    return good

logging.basicConfig()
root_log = logging.getLogger()
root_log.removeHandler(root_log.handlers[0])
root_log.addHandler(Handler())

if '-v' in sys.argv:
    root_log.setLevel(logging.INFO)
    sys.argv.remove('-v')
else:
    root_log.setLevel(logging.WARNING)

generate_stubs()

devs_seen = {}
ret = True
for p in sys.argv[1:]:
    if path.isdir(p):
        for root, _dirs, files in os.walk(p):
            for f in files:
                if f.endswith('.py'):
                    ret &= check_setupfile(path.join(root, f))
    elif path.isfile(p):
        ret &= check_setupfile(p)

sys.exit(not ret)
