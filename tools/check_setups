#!/usr/bin/env python

import os
import re
import new
import sys
import getopt
import logging
import traceback
from os import path

# force QT api to V2
try:
    import sip
    sip.setapi('QString', 2)
    sip.setapi('QVariant', 2)
except ImportError:
    pass
    # goto fail
    # goto fail

try:
    import nicos
except ImportError:
    thisfile = path.abspath(__file__)
    sys.path.insert(0, path.normpath(path.join(path.dirname(thisfile), '..')))

from nicos import config
from nicos.core.errors import ConfigurationError
from nicos.core.sessions.setups import SETUP_GROUPS
from nicos.utils.loggers import ColoredConsoleHandler, StreamHandler

# get default custom paths
default_dirs = [path.join(config.custom_path, p.strip(), 'setups')
                for p in config.setup_subdirs.split(',')]

# generate stub TACO modules as needed to be able to import nicos.devices.taco
# modules and check parameters

class NICOSTACOStub(object):
    pass

STUBS = dict(
    TACOClient = ['class Client', 'exception TACOError'],
    TACOStates = [],
    TACOCommands = [],
    DEVERRORS = [],
    IOCommon = ['MODE_NORMAL=0', 'MODE_RATEMETER=1', 'MODE_PRESELECTION=2'],
    IO = ['class AnalogInput', 'class AnalogOutput', 'class DigitalInput',
          'class DigitalOutput', 'class StringIO', 'class Timer',
          'class Counter'],
    Encoder = ['class Encoder'],
    Motor = ['class Motor'],
    PowerSupply = ['class CurrentControl', 'class VoltageControl'],
    RS485Client = ['class RS485Client'],
    Temperature = ['class Sensor', 'class Controller'],
    TMCS = ['class Channel', 'class Admin'],
    Modbus = ['class Modbus'],
    ProfibusDP = ['class IO'],
)

def generate_stubs():
    for modname, content in STUBS.iteritems():
        try:
            __import__(modname)
        except Exception:
            pass  # generate stub below
        else:
            continue
        mod = new.module(modname, "NICOS stub module")
        for obj in content:
            if obj.startswith('class '):
                setattr(mod, obj[6:], type(obj[6:], (NICOSTACOStub,), {}))
            elif obj.startswith('exception '):
                setattr(mod, obj[10:], type(obj[10:], (Exception,), {}))
            else:
                name, value = obj.split('=')
                setattr(mod, name, eval(value))
        sys.modules[modname] = mod
        root_log.info('generated TACO stub module %r' % modname)


class ConsoleHandler(ColoredConsoleHandler):
    def emit(self, record):
        # reintroduce standard logging behavior that the Nicos logger overrides
        record.message = record.getMessage()
        # remove this, the Nicos handler uses it differently
        record.filename = ''
        ColoredConsoleHandler.emit(self, record)

class FileHandler(StreamHandler):
    def __init__(self, *args):
        StreamHandler.__init__(self, *args)
        self.setFormatter(
            logging.Formatter('! %(name)s: %(levelname)s: %(message)s'))
    def emit(self, record):
        # reintroduce standard logging behavior that the Nicos logger overrides
        record.message = record.getMessage()
        # remove this, the Nicos handler uses it differently
        record.filename = ''
        StreamHandler.emit(self, record)

def nicos_import(clspath):
    modname, clsname = clspath.rsplit('.', 1)
    try:
        mod = __import__('nicos.' + modname, None, None, [clsname])
    except ImportError:
        mod = __import__(modname, None, None, [clsname])
    return getattr(mod, clsname)

def log_exception(log, exception):
    formatted_lines = traceback.format_exc().splitlines()
    msg = 'Exception while executing: %s\n|' % str(exception)
    msg += '\n|'.join(formatted_lines[-3:])
    log.error(msg)
    return False

interpol_re = re.compile(r'%[-#0 +]*(?:[0-9]+)?(?:\.(?:[0-9]+))?'
                         r'[hlL]?[diouxXeEfFgGcrs%]')

def check_parameter(log, devname, name, value):
    # for format strings, check interpolations for syntax errors
    if name == 'fmtstr':
        if '%' not in value:
            log.error('%s: parameter fmtstr has a value without any '
                      'interpolation placeholders', devname)
            return False
        else:
            # split() returns all pieces not part of a string
            # interpolation placeholder, so they must not contain
            # any % signs
            pieces = interpol_re.split(value)
            for piece in pieces:
                if '%' in piece:
                    log.error('%s: parameter fmtstr has an invalid '
                              'placeholder (%r)', devname, piece)
                    return False
    return True

def check_setupfile(filename):
    log = logging.getLogger(filename)
    good = True
    namespace = {'device': lambda c, **kw: (c, kw),
                 'setupname': path.basename(filename)[:-3]}
    # check syntax
    try:
        execfile(filename, namespace)
    except SyntaxError, e:
        msg = 'SyntaxError:\t%s' % e.msg
        msg += '\n|line: %s : %s ' % (e.lineno, e.text.strip())
        log.error(msg)
        return False
    except Exception, e:
        return log_exception(log, e)
    log.info('syntax ok')
    # check for valid group
    group = namespace.get('group', 'optional')
    if group not in SETUP_GROUPS:
        log.error('invalid setup group %r', group)
        good = False
    # check for a description
    description = namespace.get('description', None)
    if description in (None, '') and group in ('basic', 'optional'):
        log.error('missing user-friendly setup description')
        good = False
    # check if devices are duplicated
    if group != 'special':
        devs = namespace.get('devices', {})
        for devname in devs:
            if devname in devs_seen:
                log.warning('device name %s duplicate: also in %s',
                            devname, devs_seen[devname])
            else:
                devs_seen[devname] = filename
    # check for common misspelling of "includes"
    if 'include' in namespace:
        log.error("'include' list should be called 'includes'")
        good = False
    # check for types of recognized variables
    for (vname, vtype) in [('description', (str, unicode)),
                           # group is already checked against a fixed list
                           ('sysconfig', dict),
                           ('includes', list),
                           ('excludes', list),
                           ('modules', list),
                           ('devices', dict),
                           ('startupcode', str),
                           ('extended', dict)]:
        if vname in namespace and not isinstance(namespace[vname], vtype):
            log.error('%r must be of type %s (but is %s)' %
                      (vname, vtype, type(namespace[vname])))
            good = False
    # check for valid device classes (if importable) and parameters
    for devname, devconfig in namespace.get('devices', {}).iteritems():
        # try to import the device class
        try:
            cls = nicos_import(devconfig[0])
        except (ImportError, RuntimeError), err:  # the latter for SIP
            log.warning('device class %r for %r not importable: %s',
                        devconfig[0], devname, err)
            continue
        except Exception, e:
            log.error('could not get device class %r for %r:',
                      devconfig[0], devname)
            log_exception(log, e)
            good = False
            continue
        # check missing and unsupported parameter config entries
        config = devconfig[1]
        if not hasattr(cls, 'attached_devices'):
            log.warning("%s: class %r has no 'attached_devices'",
                        devname, cls.__name__)
        else:
            for aname, ainfo in cls.attached_devices.iteritems():
                try:
                    ainfo.check(None, aname, config.get(aname))
                except ConfigurationError as err:
                    log.error(ainfo)
                    log.error('%s: attached device %s (%s) is wrongly configured: %s' %
                              (devname, aname, cls.__name__, err))
                if aname in config:
                    del config[aname]
                else:
                    if ainfo.optional:
                        continue
                    log.error('%s: attached device %r missing', devname, aname)
                    good = False
        if not hasattr(cls, 'parameters'):
            log.warning("%s: class %r has no 'parameters'",
                        devname, cls.__name__)
        else:
            if not config.get('lowlevel', False):
                if not config.get('description') and group != 'special':
                    log.warning('%s: device has no description', devname)
            for pname, pinfo in cls.parameters.iteritems():
                if pname in config:
                    try:
                        pinfo.type(config[pname])
                    except ValueError, e:
                        log.error('%s: parameter %r value %r is invalid: %s',
                                  devname, pname, config[pname], e)
                        good = False
                    except TypeError, e:
                        log.error('%s: parameter %r value %r is of invalid type: %s',
                                  devname, pname, config[pname], e)
                        good = False
                    # check value of certain parameters
                    if not check_parameter(log, devname, pname, config[pname]):
                        good = False
                    del config[pname]
                elif pinfo.mandatory:
                    log.error('%s: mandatory parameter %r missing', devname, pname)
                    good = False
        if config:
            log.error('%s: configured parameters not accepted by the device '
                      'class: %s', devname, ', '.join(config))
            good = False
    return good

import optparse

parser = optparse.OptionParser(usage='usage: %prog [options] dir|file')
parser.add_option('-v', '--verbose', dest='verbose', action='store_true',
                  default=False, help='verbose output',
                 )
parser.add_option('-o', '--outfile', dest='filename', action='store',
                  default=None, type='string',
                  help='write report to FILE', metavar='FILE',
                 )

opts, args = parser.parse_args()

if not args:
    args = default_dirs

logging.basicConfig()
root_log = logging.getLogger()
root_log.removeHandler(root_log.handlers[0])
root_log.addHandler(ConsoleHandler())
root_log.setLevel(logging.WARNING)

if opts.verbose:
    root_log.setLevel(logging.INFO)
if opts.filename:
    outfile = open(opts.filename, 'ab')
    root_log.addHandler(FileHandler(outfile))

generate_stubs()

devs_seen = {}
ret = True
for p in args:
    if path.isdir(p):
        for root, _dirs, files in os.walk(p):
            for f in files:
                if f.endswith('.py'):
                    ret &= check_setupfile(path.join(root, f))
    elif path.isfile(p):
        ret &= check_setupfile(p)
    elif not path.exists(p):
        log = logging.getLogger(p)
        log.error('File not found')
        # Explicitly no negative return value as the rest of the paths
        # may have been checked.

sys.exit(not ret)
